/*!
 * (C) BKKR Framework https://bkkr-team.github.io/bkkr-docs/ - MIT License
 */
import{c as t,M as n}from"./p-e4c83805.js";import{c as a}from"./p-bf8dbf30.js";const r=()=>t().duration(400),e=n=>{let a,e;const s=n.width+8,o=t(),i=t();return n.isEndSide?(a=s+"px",e="0px"):(a=-s+"px",e="0px"),o.addElement(n.menuNativeEl).fromTo("transform",`translateX(${a})`,`translateX(${e})`),i.addElement(n.backdropEl).fromTo("opacity","0","var(--backdrop-opacity)"),r().addAnimation([o,i])},s=n=>{let a,e;const s=n.width;n.isEndSide?(a=-s+"px",e=s+"px"):(a=s+"px",e=-s+"px");const o=t().addElement(n.menuNativeEl).fromTo("transform",`translateX(${e})`,"translateX(0px)"),i=t().addElement(n.contentEl).fromTo("transform","translateX(0px)",`translateX(${a})`),c=t().addElement(n.backdropEl).fromTo("opacity","0","var(--backdrop-opacity)");return r().addAnimation([o,i,c])},o=n=>{const a=n.width*(n.isEndSide?-1:1)+"px",e=t().addElement(n.contentEl).fromTo("transform","translateX(0px)",`translateX(${a})`);return r().addAnimation(e)},i=(()=>{const t=new Map,r=[],i=async t=>{if(await w(),"start"===t||"end"===t){return m((n=>n.side===t&&!n.disabled))||m((n=>n.side===t))}if(null!=t)return m((n=>n.menuId===t));return m((t=>!t.disabled))||(r.length>0?r[0].el:void 0)},c=async()=>(await w(),l()),p=(n,a)=>{t.set(n,a)},u=t=>{const n=t.side;r.filter((a=>a.side===n&&a!==t)).forEach((t=>t.disabled=!0))},l=()=>m((t=>t._isOpen)),y=()=>r.some((t=>t.isAnimating)),m=t=>{const n=r.find(t);if(void 0!==n)return n.el},w=()=>Promise.all(Array.from(document.querySelectorAll("bkkr-menu")).map((t=>new Promise((n=>a(t,n))))));return p("reveal",o),p("push",s),p("overlay",e),"undefined"!=typeof document&&document.addEventListener("bkkrBackButton",(t=>{const a=l();a&&t.detail.register(n,(()=>a.close()))})),{registerAnimation:p,get:i,getMenus:async()=>(await w(),r.map((t=>t.el))),getOpen:c,isEnabled:async t=>{const n=await i(t);return!!n&&!n.disabled},swipeGesture:async(t,n)=>{const a=await i(n);return a&&(a.swipeGesture=t),a},isAnimating:async()=>(await w(),y()),isOpen:async t=>{if(null!=t){const n=await i(t);return void 0!==n&&n.isOpen()}return void 0!==await c()},enable:async(t,n)=>{const a=await i(n);return a&&(a.disabled=!t),a},toggle:async t=>{const n=await i(t);return!!n&&n.toggle()},close:async t=>{const n=await(void 0!==t?i(t):c());return void 0!==n&&n.close()},open:async t=>{const n=await i(t);return!!n&&n.open()},_getOpenSync:l,_createAnimation:(n,a)=>{const r=t.get(n);if(!r)throw new Error("animation not registered");return r(a)},_register:t=>{r.indexOf(t)<0&&(t.disabled||u(t),r.push(t))},_unregister:t=>{const n=r.indexOf(t);n>-1&&r.splice(n,1)},_setOpen:async(t,n,a)=>{if(y())return!1;if(n){const n=await c();n&&t.el!==n&&await n.setOpen(!1,!1)}return t._setOpen(n,a)},_setActiveMenu:u}})();export{i as m}