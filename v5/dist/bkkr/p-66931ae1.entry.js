/*!
 * (C) BKKR Framework https://bkkr-team.github.io/bkkr-docs/ - MIT License
 */
import{r as t,c as i,h as s,H as e,g as a}from"./p-3b0af71a.js";import{g as h}from"./p-87969847.js";import{a as o,d as n}from"./p-e74157ae.js";import{s as r}from"./p-6518e4d1.js";import{t as l}from"./p-b0adc7e3.js";import"./p-d7a8dd59.js";let c=class{constructor(s){t(this,s),this.bkkrNavWillLoad=i(this,"bkkrNavWillLoad",7),this.bkkrNavWillChange=i(this,"bkkrNavWillChange",3),this.bkkrNavDidChange=i(this,"bkkrNavDidChange",3),this.gestureOrAnimationInProgress=!1,this.animated=!0,this.nested=!1}swipeHandlerChanged(){this.gesture&&this.gesture.enable(void 0!==this.swipeHandler)}async connectedCallback(){const t=()=>{this.gestureOrAnimationInProgress=!0,this.swipeHandler&&this.swipeHandler.onStart()};this.gesture=(await __sc_import_bkkr("./p-7976d4a9.js")).createSwipeBackGesture(this.el,(()=>!this.gestureOrAnimationInProgress&&!!this.swipeHandler&&this.swipeHandler.canStart()),(()=>t()),(t=>this.ani&&this.ani.progressStep(t)),((t,i,s)=>{if(this.ani){this.ani.onFinish((()=>{this.gestureOrAnimationInProgress=!1,this.swipeHandler&&this.swipeHandler.onEnd(t)}),{oneTimeCallback:!0});let e=t?-.001:.001;t?e+=h([0,0],[.32,.72],[0,1],[1,1],i)[0]:(this.ani.easing("cubic-bezier(1, 0, 0.68, 0.28)"),e+=h([0,0],[1,0],[.68,.28],[1,1],i)[0]),this.ani.progressEnd(t?1:0,e,s)}else this.gestureOrAnimationInProgress=!1})),this.swipeHandlerChanged()}componentWillLoad(){this.bkkrNavWillLoad.emit()}disconnectedCallback(){this.gesture&&(this.gesture.destroy(),this.gesture=void 0)}async commit(t,i,s){const e=await this.lock();let a=!1;try{a=await this.transition(t,i,s)}catch(t){console.error(t)}return e(),a}async setRouteId(t,i,s){return{changed:await this.setRoot(t,i,{duration:"root"===s?0:void 0,direction:"back"===s?"back":"forward"}),element:this.activeEl}}async getRouteId(){const t=this.activeEl;return t?{id:t.tagName,element:t,params:this.activeParams}:void 0}async setRoot(t,i,s){if(this.activeComponent===t&&r(i,this.activeParams))return!1;const e=this.activeEl,a=await o(this.delegate,this.el,t,["bkkr-page","bkkr-page-invisible"],i);return this.activeComponent=t,this.activeEl=a,this.activeParams=i,await this.commit(a,e,s),await n(this.delegate,e),!0}async transition(t,i,s={}){if(i===t)return!1;this.bkkrNavWillChange.emit();const{el:e}=this,a=this.animated,h=s.animationBuilder||this.animation;return await l(Object.assign(Object.assign({animated:a,enteringEl:t,leavingEl:i,baseEl:e,progressCallback:s.progressAnimation?t=>{void 0===t||this.gestureOrAnimationInProgress?this.ani=t:(this.gestureOrAnimationInProgress=!0,t.onFinish((()=>{this.gestureOrAnimationInProgress=!1,this.swipeHandler&&this.swipeHandler.onEnd(!1)}),{oneTimeCallback:!0}),t.progressEnd(0,0,0))}:void 0},s),{animationBuilder:h})),this.bkkrNavDidChange.emit(),!0}async lock(){const t=this.waitPromise;let i;return this.waitPromise=new Promise((t=>i=t)),void 0!==t&&await t,i}render(){const{nested:t}=this;return s(e,{class:{nested:t}},s("slot",null))}get el(){return a(this)}static get watchers(){return{swipeHandler:["swipeHandlerChanged"]}}};c.style=":host{top:0;right:0;bottom:0;left:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}:host(.nested){position:relative;contain:unset;}:host(.nested) ::slotted(.bkkr-page){position:relative !important;contain:unset !important}";export{c as bkkr_router_outlet}